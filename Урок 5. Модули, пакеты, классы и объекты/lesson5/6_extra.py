# Исследуя классы подробнее
# стр. 721 про создание пустого сласса, заполнение полей и наследование от
# него реальных объктов с заполненными атрибутами

# создадим самый простой в мире класс:
class Man: pass

# присвоим классу атрибуты
Man.name = 'Ivan'
Man.age  = 33

# Классы – это полноценные объекты, даже если нет ни одного экземпляра. 
# фактические класс - это самостоятельное пространство имен
# поэтому, пока у нас имеется ссылка на класс, мы можем в любое время
# добавлять или изменять его атрибуты по своему усмотрению. 

x = Man()
y = Man()

# В действительности у этих экземпляров нет собственных атрибутов 
# – они просто получают атрибут name из класса.
print(x.name, y.name)

x.name = 'Vasily'
print(x.name, y.name)

# переопределим значение атрибута через класс
print(x.age, y.age)
Man.age = 99
print(x.age, y.age) # все экземпляры класса имеют доступ атрибуту age
# может использоваться для хранения информации, доступной всем экземплярам


# __dict__ является словарем пространства имен
print(list(Man.__dict__.keys()))
print(x.__dict__) # age из класса, а name в самом объекте
print(y.__dict__) # пусто. все атрибуты берутся из класса


# Каждый экземпляр имеет ссылку на свой класс:
print(x.__class__)
print(x.__class__.__name__)

# Классы имеют атрибут для доступа к кортежу суперклассов:
print(Man.__bases__)
print(x.__class__.__bases__)

# Методы могут создаваться независимо от объекта класса
def upname(self):
    print( self.name.upper() )

Man.upper_name = upname

x.upper_name()
y.upper_name()

# можно вызвать через метод самого класса, передав объект вручную
Man.upper_name(x)


# Внутренние методы классов
class BB:
    _a = 10
    __b = 100

print(dir(BB))

