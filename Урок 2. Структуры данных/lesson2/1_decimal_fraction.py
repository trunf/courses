
# =================================
#       Decimal (десятичное)
# =================================

print('Decimal')

# Дробные числа «для людей»
# Основная идея чисел Decimal в том, что компьютеры должны обеспечивать арифметические 
# операции таким образом, чтобы операции над дробными числами работали также, 
# как арифметика, изучаемая в школе.

# проблема с float
print(1.1+2.2)
# должно быть равно нулю, но это не так
print(0.1+0.1+0.1-0.3) 

from decimal import *

# Создание десятичного числа из целого, строки, вещественного и из кортежа:
print(Decimal(10))
print(Decimal('3.14'))
print(Decimal(0.1))
print(Decimal((0, (3,1,4), -3)))

print( Decimal(2) + Decimal('3.14') )

print( Decimal('Infinity') )

# Округление
# слишком большое количество цифр после запятой:
print( Decimal("1.10") / 3 )

a = Decimal('17.3299').quantize(Decimal('.01'))
b = Decimal('7.499').quantize(Decimal('1.'))
print(a, b)

# Можно объявить константу, чтобы постоянно не писать Decimal('.01'):
TWOPLACES = Decimal(10) ** -2
d = Decimal('7.3299').quantize(TWOPLACES)
print(d)


# =================================
#        Fraction (дробное)
# =================================

print()
print('Fraction')

# Дробные числа появились в Python 2.6
# Перед использованием необходимо импортировать класс дробного числа
from fractions import Fraction
a = Fraction(1,2)
b = Fraction(3,2)
print(a+b)

# Создание дробного числа из вещественного и из строки
a = Fraction(0.5)
b = Fraction('3/2')
print(a+b)

# Из-за ограничений двоичной арифметики с плавающей точкой
# Fraction(1.1) не является в точности Fraction(11,10), как это следовало бы предположить
print(Fraction(1.1))

# Для решения подобных проблем применяется метод limit_denominator(max_denominator=1000000)
# Метод находит и возвращает ближайшее к себе дробное число, 
# знаменатель которого не более max_denominator:
print(Fraction(1.1).limit_denominator())
